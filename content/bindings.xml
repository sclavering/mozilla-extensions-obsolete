<?xml version="1.0"?>

<bindings id="ToolbarExtBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">
 
  <binding id="toolbar" extends="chrome://global/content/widgets/toolbar.xml#toolbar-base">
    <implementation>
      <field name="firstPermanentChild">null</field>
      <field name="lastPermanentChild">null</field>
      
      <property name="toolbarName"
                onget="return this.getAttribute('toolbarname');"
                onset="this.setAttribute('toolbarname', val); return val;"/>
      
      <property name="currentSet">
        <getter>
          <![CDATA[
            var node = this.firstChild;
            var currentSet = "";
            while (node) {
              if (node.id &&
                  node.localName == "toolbaritem" || 
                  node.localName == "toolbarbutton" ||
                  node.localName == "toolbarseparator" ||
                  node.localName == "toolbarspring" ||
                  node.localName == "toolbarspacer")
              {
                if (currentSet)
                  currentSet += ",";

                if (node.localName == "toolbarseparator")
                  currentSet += "separator";
                else if (node.localName == "toolbarspring")
                  currentSet += "spring";
                else if (node.localName == "toolbarspacer")
                  currentSet += "spacer";
                else
                  currentSet += node.id;
              }
              node = node.nextSibling;
            }
            
            return currentSet ? currentSet : "__empty";
          ]]>
        </getter>
        
        <setter>
          <![CDATA[
            // Remove all items before the first permanent child and after the last permanent child.
            while (this.lastChild) {
              if (this.lastChild == this.lastPermanentChild ||
                  (this.lastChild.localName == "toolbarpaletteitem" &&
                  this.lastChild.firstChild == this.lastPermanentChild))
                break;
              this.removeChild(this.lastChild);
            }

            while (this.firstChild) {
              if (this.firstChild == this.firstPermanentChild ||
                  (this.firstChild.localName == "toolbarpaletteitem" &&
                  this.firstChild.firstChild == this.firstPermanentChild))
                break;
              this.removeChild(this.firstChild);
            }

            var firstChildID = this.firstPermanentChild ? this.firstPermanentChild.id : "";
            var lastChildID = this.lastPermanentChild ? this.lastPermanentChild.id : "";

            if (val == "__empty")
              return;

            if (val) {
              var itemIds = val.split(",");
              var before = true;
              for (var i = 0; i < itemIds.length; i++) {
                if (itemIds[i] == firstChildID || itemIds[i] == lastChildID)
                  before = false;
                else
                  this.insertItem(itemIds[i], null, null, before);
              }
            }
          ]]>
        </setter>
      </property>
      
      <method name="insertItem">
        <parameter name="aId"/>
        <parameter name="aBeforeElt"/>
        <parameter name="aWrapper"/>
        <parameter name="aBeforePermanent"/>
        <body>
          <![CDATA[
            var newItem = null;
            
            // Create special cases of palette items.
            var uniqueId;
            if (aId == "separator") {
              newItem = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                                 "toolbarseparator");
              uniqueId = (new Date()).getTime()+this.childNodes.length;
              newItem.id = "separator" + uniqueId;
            } else if (aId == "spring") {
              newItem = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                                 "toolbarspring");
              uniqueId = (new Date()).getTime()+this.childNodes.length;
              newItem.flex = 1;
              newItem.id = "spring" + uniqueId;
            } else if (aId == "spacer") {
              newItem = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                                 "toolbarspacer");
              uniqueId = (new Date()).getTime()+this.childNodes.length;
              newItem.id = "spacer" + uniqueId;
            } else {
              // Attempt to locate an item with a matching id within palette.
              var paletteItem = this.parentNode.palette.firstChild;
              while (paletteItem) {
                var paletteId = paletteItem.id;
                if (paletteId == aId) {
                  newItem = paletteItem.cloneNode(true);
                  break;
                }
                paletteItem = paletteItem.nextSibling;
              }
            }
            
            if (!newItem)
              return false;

            var insertItem = newItem;
            
            // Wrap the item in another node if so inclined.
            if (aWrapper) {
              aWrapper.appendChild(newItem);
              insertItem = aWrapper;
            }
            
            // Insert the palette item into the toolbar.
            if (aBeforeElt)
              this.insertBefore(insertItem, aBeforeElt);
            else if (aBeforePermanent && this.firstPermanentChild)
                this.insertBefore(insertItem, this.firstPermanentChild);
            else
                this.appendChild(insertItem);
               
            return newItem;
          ]]>
        </body>
      </method>      

      <constructor>
        <![CDATA[
          // for compatibility with fb0.7 and nightlies pre sept 10ish
          // for those builds toolbar elements get constructed before
          // the toolbox that contains them, so the toolbar needs to
          // initialise the palette, rather than the toolbox doing it
          var toolbox = this.parentNode;
          if(!(("palette" in toolbox) && toolbox.palette)) {
            var paletteId = toolbox.getAttribute("palette");
            if(!("toolbarpalettes" in document))
              document.toolbarpalettes = new Array();
            if(paletteId in document.toolbarpalettes) {
              toolbox.palette = document.toolbarpalettes[paletteId];
            } else {
              var palette = document.getElementById(paletteId);
              palette.parentNode.removeChild(palette);
              document.toolbarpalettes[paletteId] = palette;
              toolbox.palette = palette;
            }
          }

          this.firstPermanentChild = this.firstChild;
          this.lastPermanentChild = this.lastChild;
         
          // Build up our contents from the palette
          var currentSet = this.getAttribute("currentset");
          if(!currentSet) currentSet = this.getAttribute("defaultset");
          if(currentSet) this.currentSet = currentSet;

          //throw "Toolbar bound. id="+this.id;
        ]]>
      </constructor>
    </implementation>
  </binding>


  <binding id="customisable-toolbox" extends="chrome://global/content/widgets/toolbar.xml#toolbar-base">  
    <implementation>     
      <field name="palette">null</field>
      
      <field name="toolbarset">null</field>
      
      <field name="customToolbarCount">0</field>
      
      <constructor>
        <![CDATA[
          // initialise palette.  we leave it in a hash on the document
          // for other toolboxes to use too.
          var paletteId = this.getAttribute("palette");
          if(!("toolbarpalettes" in document))
            document.toolbarpalettes = new Array();
          if(paletteId in document.toolbarpalettes) {
            this.palette = document.toolbarpalettes[paletteId];
          } else {
            var palette = document.getElementById(paletteId);
            palette.parentNode.removeChild(palette);
            document.toolbarpalettes[paletteId] = palette;
            this.palette = palette;
          }
          
          // Look to see if there is a toolbarset.
          this.toolbarset = this.firstChild;
          while (this.toolbarset && this.toolbarset.localName != "toolbarset")
            this.toolbarset = toolbarset.nextSibling;
          
          if(this.toolbarset) {
            // Create each toolbar described by the toolbarset.
            var index = 0;
            while (toolbarset.hasAttribute("toolbar"+(++index))) {
              var toolbarInfo = toolbarset.getAttribute("toolbar"+index);
              var infoSplit = toolbarInfo.split(":");
              this.appendCustomToolbar(infoSplit[0], infoSplit[1], false);
            }
          }
          
          // restore toolbar modes, collapsed-ness, and icon size
          for(var node = this.firstChild; node; node = node.nextSibling) {
            if(node.localName!="toolbar") continue;
            var id = node.id;
            
            var collapsed = this.getAttribute(id+"-collapsed")=="true";
            node.collapsed = collapsed;

            var mode = this.getAttribute(id+"-mode");
            if(mode) node.setAttribute("mode",mode);
            
            var iconsize = this.getAttribute(id+"-iconsize");
            if(iconsize) node.setAttribute("iconsize",iconsize);
            
            var fullscreen = this.getAttribute(id+"-showfullscreen");
            if(fullscreen) node.setAttribute("fullscreentoolbar","true");
          }
          //throw "toolbox bound. id="+this.id;
        ]]>
      </constructor>
      
      <method name="appendCustomToolbar">
        <parameter name="aName"/>
        <parameter name="aCurrentSet"/>
        <parameter name="inCustomisationMode"/>
        <body>
          <![CDATA[            
            var toolbar = document.createElementNS("http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                                  "toolbar");
            toolbar.id = "__customToolbar_" + aName.replace(" ", "");
            toolbar.setAttribute("customizable", "true");
            toolbar.setAttribute("customindex", ++this.customToolbarCount);
            toolbar.setAttribute("toolbarname", aName);
            toolbar.setAttribute("currentset", aCurrentSet);
            toolbar.setAttribute("mode", this.getAttribute("mode"));
            toolbar.setAttribute("iconsize", this.getAttribute("iconsize"));
            // while in customisation mode we use different context menus,
            // and store the normal-mode context menu in an |oldcontext| attr
            var context = inCustomisationMode ? "oldcontext" : "context";
            toolbar.setAttribute(context, this.toolbarset.getAttribute("context"));
            toolbar.setAttribute("class", "chromeclass-toolbar");
            
            this.insertBefore(toolbar, this.toolbarset);
            return toolbar;
          ]]>
        </body>
      </method>
      
      <!-- the following methods are used because we can't just persist() the state of the
           various attributes they set on toolbars, because the toolbars haven't been created
           at the point where persisted attributes are restored. -->
      <method name="hideToolbar">
        <parameter name="aToolbar"/>
        <parameter name="aHide"/>
        <body><![CDATA[
          aToolbar.collapsed = aHide;
          var attr = aToolbar.id+"-collapsed";
          if(aHide) this.setAttribute(attr,aHide);
          else this.removeAttribute(attr);
          document.persist(this.id,attr);
        ]]></body>
      </method>

      <method name="setToolbarMode">
        <parameter name="aToolbar"/>
        <parameter name="aMode"/>
        <body><![CDATA[
          aToolbar.setAttribute("mode",aMode);
          var attr = aToolbar.id+"-mode"
          this.setAttribute(attr,aMode);
          document.persist(this.id,attr);
        ]]></body>
      </method>
      
      <method name="setToolbarIconSize">
        <parameter name="aToolbar"/>
        <parameter name="aSize"/>
        <body><![CDATA[
          var attr = aToolbar.id+"-iconsize";
          aToolbar.setAttribute("iconsize",aSize);
          this.setAttribute(attr,aSize);
          document.persist(this.id,attr);
        ]]></body>
      </method>

      <method name="showToolbarInFullscreen">
        <parameter name="aToolbar"/>
        <parameter name="aShow"/>
        <body><![CDATA[
          var attr = aToolbar.id+"-showfullscreen";
          if(aShow) {
            aToolbar.setAttribute("fullscreentoolbar","true");
            this.setAttribute(attr,aShow);
          } else {
            aToolbar.removeAttribute("fullscreentoolbar");
            this.removeAttribute(attr);
          }
          document.persist(this.id,attr);
        ]]></body>
      </method>
    </implementation>
  </binding>
 
 
  <!-- like chrome://global/content/widgets/toolbar.xml#toolbarpaletteitem, but with a vbox rather than hbox -->
  <binding id="toolbarpaletteitem-vertical" extends="chrome://global/content/widgets/toolbar.xml#toolbar-base" display="xul:button">
    <content>
      <xul:vbox class="toolbarpaletteitem-box" flex="1" xbl:inherits="type,place">
        <children/>
      </xul:vbox>
    </content>
  </binding>
  
</bindings>